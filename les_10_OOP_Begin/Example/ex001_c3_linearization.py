"""
C3-линеаризация — это алгоритм, используемый в некоторых языках программирования для определения порядка,
 в котором классы должны быть исследованы при поиске методов, если присутствует множественное наследование,
 и гарантирующий, что порядок будет однозначным и консистентным. Этот алгоритм нашел свое применение в языке
 программирования Python для решения проблемы ромбовидного наследования, когда класс наследует от двух классов,
 которые в свою очередь наследуют от одного и того же суперкласса.

Проблема ромбовидного наследования возникает, потому что существует два разных пути от производного класса к базовому
классу, что может привести к неоднозначности в том, какой путь следует выбрать при поиске метода. C3-линеаризация
помогает обеспечить единственный "правильный" порядок вызова методов.

Как работает C3-линеаризация:
C3-линеаризация строит так называемый линеаризованный список классов, который определяет порядок, в котором методы
будут искаться. Для построения этого списка алгоритм учитывает следующие три правила:

Порядок дочерних классов: Дочерний класс всегда посещается раньше своих родительских классов.
Порядок, заданный в определении класса: Родительские классы посещаются в том порядке, в котором они указаны
 в определении класса.
Консистентность: Если класс X предшествует классу Y в линеаризации какого-либо подкласса, то X предшествует
Y в линеаризации любого класса.

Пример в Python:
Рассмотрим следующую иерархию классов:
"""

class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass

"""
Используя C3-линеаризацию, Python определит порядок поиска методов для класса D как D, B, C, A. Это означает,
 что если метод не найден в D, поиск будет продолжен в B, затем в C, и, наконец, в A.

Метод mro() в Python возвращает линеаризованный список классов, определенный с использованием C3-линеаризации:
"""

print(D.mro())
# Вывод: [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
